---
layout: post
title:  "raft算法总结"
date:   2018-12-21 11:49:45 +0200
categories: 一致性 算法 分布式
---
英文论文地址：[raft](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)

中文论文地址：[raft](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)

Raft 是一个一致性算法，主要用来解决日志复制的一致性问题，原先针对日志复制的一致性问题，基本解决方案都是Paxos算法，但Paxos太过于难懂，且给出实现细节太少，很少有人能根据论文实现，故raft算法被发明出来，算法的第一重点便是可理解性。

首先明确一下什么是日志复制，客户端发送命令给服务器，服务器会把该命令log下来，然后会把该命令发送给其他多台备份服务器（不然一个机子挂了整体就挂了，也就是说我们看上去是一台服务器，其实背后有5台，一台挂了就切换到另一台，所以要保证这5台的状态是一样的，5台的好处是就就算有2台挂了系统也可以照样工作），当大部分机子（3台）纪录下这个命令后，主服务器便执行这个命令，并返回响应的结果，然后备份服务器也会执行相应的命令，以保证所有服务器之间的状态是一样的。

其次明确下Raft算法的几个重要点：
1. Raft算法会选出一个领导人，这是与Paxos最大的不同，Raft算法中领导人的选举，大大简化了之后的操作。
+ 1.1 只有一个领导人，其他都是跟随者，如果一段时间没有收到领导人的心跳，则可以发出“我要竞选”的投票
+ 1.2 加入随机化，即每个候选者等待时间不一样，使得竞争冲突减少，大大增加了选举成功的可能性
+ 1.3 面对其他候选者发出的投票，只有当对方的日志比我的新的时候才能同意，这样保证了选举出来的领导人一定拥有最新日志

2. Raft算法的领导人本身日志不变，跟随者需要保持和领导人一模一样（可能会删除掉部分和领导人不匹配的日志）
+ 2.1 领导人会维护对每一个跟随者，下一次要发送的日志索引处
+ 2.2 跟随者在应用领导人发送过来的日志时，需要检测该日志前面的日志有没有对应上，是的话就保存日志，不是的话通知领导人更新对自己的维护，直到某个点匹配了，在该点之后直接用领导者的日志进行覆盖
+ 2.3 当一个命令被大多数跟随者接收后，领导人认为该命令是可以被提交的，然后会执行该命令，改变状态机并返回结果
+ 2.4 在命令没有被提交之前，就算是已经被大多数跟随者接收，也可能之后会被覆盖掉，见论文图8

然后：
<p>
广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）
这个是保证系统正常运行的前提，一般来说至少差上一个数量级
</p>
最后， [Raft Visualization](https://raft.github.io/) 这个算法的动画很不错，可以手动制造很多情况，可以查看维护的变量是怎么变化的，对理解算法有很大的帮助
