---
layout: post
title:  "垃圾回收算法简单归纳"
date:   2018-12-22 11:49:45 +0200
categories: 垃圾回收 算法
---
参考资料：《垃圾回收的算法与实现》，简单易懂，强烈推荐

程序垃圾定义：分配到堆中的且不能通过程序引用的对象

垃圾回收(Garbage Collection)定义：
1. 寻找到程序垃圾
2. 回收垃圾，让程序员能重新利用这部分空间

垃圾回收的最基本的三种算法：

标记-清除算法
=====

算法原理：该算法分成标记和清除两个步骤。

步骤一：标记，即从根对象（调用栈，寄存器，全局变量空间）标记所有能被引用到的对象为活动对象
![png1]({{ site.baseurl }}/assets/img/gc/1.png){: .center-image }

步骤二：清除，清除并回收非活动对象，即不被引用的那些对象
![png2]({{ site.baseurl }}/assets/img/gc/2.png){: .center-image }

算法优点：
+ 实现简单
+ 与保守式GC算法兼容，因其不用移动对象

算法缺点：
+ 碎片化：由上图可知，清除阶段之后回收到的一个个小空间会被链接到空闲链表，这样就会导致碎片化
由于分块不是连续的，故每次分配空间都需要遍历一遍空闲链表，效率较低
+ 与写时复制不兼容，因为每次需要标记哪些对象是活动对象，会频繁发生不必要的复制。


引用计数法
=====

算法原理：让所有对象事先记录由多少对象在引用自己，当引用数为0的时候，自动回收该对象。

算法示意图：
![png3]({{ site.baseurl }}/assets/img/gc/3.png){: .center-image }

算法优点：
+ 可以即刻回收垃圾
+ 最大暂停时间短，像标记清除算法，在执行GC的时候需要暂停整个程序，直到GC完成，引用技术法因为只关注某个对象的引用数，故暂停时间会很短

算法缺点：
+ 计数器值的增减处理繁重，每当指针更新时，都需要更新计数器
+ 计数器会占用多个位，内存利用率不高
+ 算法简单，但实现繁琐复杂
+ 无法解决循环引用问题

GC复制算法
=====

算法原理：将堆空间平分成两部分FROM和TO,每次分配对象只利用其中之一，在垃圾回收的时候，把FROM中的活动对象拷贝到TO中，然后把整个FROM空间回收掉，下一次把原来的TO空间当成FROM空间。

算法示意图：
![png4]({{ site.baseurl }}/assets/img/gc/4.png){: .center-image }

算法优点：
+ 优秀的吞吐量，该算法只搜索并复制活动对象，相比一般的标记-清除算法要快
+ 可实现高速分配，因为该算法不用空闲链表，是一整块大内存在那里等着分配，这也是它比标记-清除更快的原因之一
+ 不会发生碎片化

算法缺点：
+ 堆的使用效率低下，因为其每次只使用一半的堆
+ 不兼容保守式GC算法


其他的垃圾回收算法均基于以上3种最基本的算法，或做一些组合，或做一些改进：

+ 标记-压缩算法：结合标记-清除和复制算法，先标记所有活动对象，再进行压缩，主要是不需要在牺牲半个堆
+ 分代垃圾回收：一般分为新生代和老年代，老年代不用频繁的执行垃圾回收。新生代可以使用复制算法，老年代一般使用标记清除算法，可以改善总体垃圾回收所话费的时间
+ 增量式垃圾回收：分割标记-清除算法，不是一次性执行完，而是将这个算法分成若干个阶段，每次只执行一部分，主要是缩短程序暂停时间
